#!/usr/bin/env -S uv run --script
# -*- mode: python -*-
# /// script
# requires-python = ">=3.10"
# dependencies = [
#     "click",
#     "dnspython",
#     "ipaddress",
#     "requests",
#     "rich",
#     "ruamel.yaml",
# ]
# ///
"""
Hetzner DNS Manager

A command-line tool with local database to interact with the Hetzner DNS API.

Designed and implemented in 2025 by Steffen Beyer (and Claude Code).
"""

import ipaddress
import os
import pathlib
import re
import sys
from dataclasses import dataclass, field
from typing import List

import click
import dns.resolver
import requests
from rich.console import Console
from rich.table import Table
from ruamel.yaml import YAML

# Constants
VERSION = "0.1.0"
API_BASE_URL = "https://dns.hetzner.com/api/v1"
ZONES_DIR = pathlib.Path("./zones")

# Ensure zones directory exists
ZONES_DIR.mkdir(exist_ok=True)

# Read API token from environment
API_TOKEN = os.environ.get("HETZNER_DNS_API_TOKEN")

# Set up console for rich output
console = Console()


@dataclass
class Record:
    """DNS Record data structure with validation."""

    id: str
    type: str
    name: str
    value: str

    def __post_init__(self):
        """Validate record fields strictly based on DNS standards."""
        # Validate ID - should be a hexadecimal string of specific length or empty for new records
        if self.id:
            if not isinstance(self.id, str):
                raise ValueError("Record ID must be a string")

            # Hetzner record IDs are 32-char hex strings
            if not re.match(r"^[0-9a-f]{32}$", self.id):
                raise ValueError(
                    f"Record ID '{self.id}' must be a 32-character hexadecimal string"
                )

        # Validate record type
        if not self.type:
            raise ValueError("Record type cannot be empty")

        valid_record_types = [
            "A",
            "AAAA",
            "CNAME",
            "MX",
            "TXT",
            "NS",
            "SOA",
            "SRV",
            "CAA",
            "PTR",
        ]
        if self.type not in valid_record_types:
            raise ValueError(
                f"Invalid record type: {self.type}. Must be one of {', '.join(valid_record_types)}"
            )

        # Name can be empty (represented as "@") or a valid hostname
        if not isinstance(self.name, str):
            raise ValueError("Record name must be a string")

        # Value validation based on record type
        if not self.value:
            raise ValueError("Record value cannot be empty")

        # Type-specific validation using pattern matching
        match self.type:
            case "A":
                # IPv4 address validation
                try:
                    ipaddress.IPv4Address(self.value)
                except ValueError:
                    raise ValueError(f"Invalid IPv4 address for A record: {self.value}")

            case "AAAA":
                # Strict IPv6 validation using ipaddress module
                try:
                    ipaddress.IPv6Address(self.value)
                except ValueError:
                    raise ValueError(
                        f"Invalid IPv6 address for AAAA record: {self.value}"
                    )

            case "MX":
                # MX records should have format "priority hostname"
                if not re.match(r"^\d+\s+\S+$", self.value):
                    raise ValueError(
                        f"Invalid MX record format: {self.value}. Expected format: '10 mail.example.com.'"
                    )

                # Extract priority and check if it's within valid range (0-65535)
                try:
                    priority = int(self.value.split()[0])
                    if priority < 0 or priority > 65535:
                        raise ValueError(
                            f"Invalid MX priority: {priority}. Must be between 0 and 65535"
                        )
                except (ValueError, IndexError):
                    raise ValueError(f"Invalid MX priority in record: {self.value}")

            case "TXT":
                # TXT records should be quoted
                if not (
                    self.value.startswith('"')
                    and (self.value.endswith('"') or ' "' in self.value)
                ):
                    raise ValueError(
                        f"Invalid TXT record format: {self.value}. Value should be quoted"
                    )

            case "SOA":
                # SOA records have a specific format with 7 parts
                parts = self.value.split(" ")
                if len(parts) != 7:
                    raise ValueError(
                        f"Invalid SOA record format: {self.value}. Expected format: 'primary_ns admin_email serial refresh retry expire minimum'"
                    )

                # Check if the serial, refresh, retry, expire, and minimum are numeric
                for i in range(2, 7):
                    try:
                        int(parts[i])
                    except ValueError:
                        raise ValueError(
                            "Invalid SOA record: numeric values required for serial, refresh, retry, expire, and minimum"
                        )

            case "CNAME":
                # CNAME records should point to a hostname
                if not self.value:
                    raise ValueError("CNAME record value cannot be empty")

                # Basic hostname validation
                if not re.match(
                    r"^[a-zA-Z0-9]([a-zA-Z0-9\-\.]*[a-zA-Z0-9])?\.?$", self.value
                ):
                    raise ValueError(
                        f"Invalid hostname format for CNAME record: {self.value}"
                    )

            case _:
                # Other record types have no specific validation beyond the basic checks above
                pass


@dataclass
class Zone:
    """DNS Zone data structure with validation."""

    id: str
    name: str
    records: List[Record] = field(default_factory=list)

    def __post_init__(self):
        """Validate zone fields strictly according to Hetzner DNS standards."""
        # Validate ID
        if not isinstance(self.id, str):
            raise ValueError("Zone ID must be a string")

        if not self.id:
            raise ValueError("Zone ID cannot be empty")

        # Hetzner zone IDs are 22-character alphanumeric strings
        if not re.match(r"^[a-zA-Z0-9]{22}$", self.id):
            raise ValueError(
                f"Zone ID '{self.id}' must be a 22-character alphanumeric string"
            )

        # Validate zone name (domain name)
        if not isinstance(self.name, str):
            raise ValueError("Zone name must be a string")

        if not self.name:
            raise ValueError("Zone name cannot be empty")

        # Basic domain name validation
        # Domain names should be RFC 1035 compliant
        if not re.match(
            r"^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$",
            self.name,
        ):
            raise ValueError(f"Invalid domain name format for zone: {self.name}")

        # Validate records list
        if not isinstance(self.records, list):
            raise ValueError("Records must be a list")

        # Check for duplicate records (same type, name, and value)
        record_keys = set()
        for record in self.records:
            key = (record.type, record.name, record.value)
            if key in record_keys:
                raise ValueError(
                    f"Duplicate record found: {record.type} {record.name} {record.value}"
                )
            record_keys.add(key)

        # Sort records by type, then name
        self.records.sort(key=lambda r: (r.type, r.name))


class HetznerDNSClient:
    """Client for interacting with the Hetzner DNS API."""

    def __init__(self, api_token, dry_run=False):
        self.api_token = api_token
        self.headers = {"Auth-API-Token": api_token, "Content-Type": "application/json"}
        self.dry_run = dry_run

    def _dry_run_handler(self, method, url, params=None, json=None):
        """Handle API request in dry run mode."""
        console.print("\n[bold]Dry run - API request that would be sent:[/]")
        console.print(f"{method.upper()} {url}" + (f"?{params}" if params else ""))
        console.print(
            "Headers: {'Auth-API-Token': '***', 'Content-Type': 'application/json'}"
        )
        if json:
            console.print(f"Payload: {json}")
        sys.exit(0)

    def make_request(self, method, url, params=None, json=None):
        """Make API request with pattern matching for HTTP methods."""
        if self.dry_run:
            self._dry_run_handler(method, url, params, json)

        try:
            match method.lower():
                case "get":
                    response = requests.get(url, params=params, headers=self.headers)
                case "post":
                    response = requests.post(url, headers=self.headers, json=json)
                case "put":
                    response = requests.put(url, headers=self.headers, json=json)
                case "delete":
                    response = requests.delete(url, headers=self.headers)
                case _:
                    raise ValueError(f"Unsupported HTTP method: {method}")

            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            console.print(f"[bold red]Error:[/] {str(e)}")
            sys.exit(1)

    def get_all_zones(self):
        """Get all zones from the API."""
        url = f"{API_BASE_URL}/zones"
        return self.make_request("get", url)

    def get_zone_records(self, zone_id):
        """Get all records for a specific zone."""
        url = f"{API_BASE_URL}/records"
        params = {"zone_id": zone_id}
        return self.make_request("get", url, params)

    def delete_record(self, record_id):
        """Delete a specific record."""
        url = f"{API_BASE_URL}/records/{record_id}"
        return self.make_request("delete", url)

    def bulk_update_records(self, records):
        """Update multiple records at once."""
        url = f"{API_BASE_URL}/records/bulk"
        payload = {"records": records}
        return self.make_request("put", url, json=payload)

    def bulk_create_records(self, records):
        """Create multiple records at once."""
        url = f"{API_BASE_URL}/records/bulk"
        payload = {"records": records}
        return self.make_request("post", url, json=payload)


class YAMLHandler:
    """Handler for YAML file operations."""

    def __init__(self):
        self.yaml = YAML()
        self.yaml.indent(mapping=2, sequence=4, offset=2)
        self.yaml.preserve_quotes = True

    def read_zone(self, domain):
        """Read a zone file from disk."""
        file_path = ZONES_DIR / f"{domain}.yaml"

        if not file_path.exists():
            return None

        with open(file_path, "r") as f:
            data = self.yaml.load(f)

        # Create zone object
        zone = Zone(id=data["id"], name=data["name"], records=[])

        # Add records
        for record_data in data.get("records", []):
            record = Record(
                id=record_data["id"],
                type=record_data["type"],
                name=record_data["name"],
                value=record_data["value"],
            )
            zone.records.append(record)

        # Sort records
        zone.records.sort(key=lambda r: (r.type, r.name))

        return zone

    def write_zone(self, zone):
        """Write a zone file to disk."""
        file_path = ZONES_DIR / f"{zone.name}.yaml"

        # Prepare data for serialization
        data = {
            "id": zone.id,
            "name": zone.name,
            "records": [
                {
                    "id": record.id,
                    "type": record.type,
                    "name": record.name,
                    "value": record.value,
                }
                for record in sorted(zone.records, key=lambda r: (r.type, r.name))
            ],
        }

        with open(file_path, "w") as f:
            self.yaml.dump(data, f)

        return file_path


def check_dns_record(record, zone_name):
    """
    Check if a DNS record matches the actual DNS entry.
    Returns a string status: 'match', 'mismatch', or 'missing'.
    """
    resolver = dns.resolver.Resolver()

    # First, get the authoritative nameservers for this domain
    try:
        ns_answers = dns.resolver.resolve(zone_name, "NS")
        if ns_answers:
            # Set the first authoritative nameserver as our resolver
            auth_ns = str(ns_answers[0]).rstrip(".")

            # Try to get both IPv4 and IPv6 addresses
            nameserver_ips = []

            # Try IPv4 first
            try:
                a_records = dns.resolver.resolve(auth_ns, "A")
                for a_record in a_records:
                    nameserver_ips.append(str(a_record))
            except Exception:
                pass

            # Try IPv6 if available
            try:
                aaaa_records = dns.resolver.resolve(auth_ns, "AAAA")
                for aaaa_record in aaaa_records:
                    nameserver_ips.append(str(aaaa_record))
            except Exception:
                pass

            # If we got any nameserver IPs, use them
            if nameserver_ips:
                resolver.nameservers = nameserver_ips
    except Exception:
        # If we can't get authoritative nameservers, continue with default resolver
        pass

    try:
        # Handle domain name formatting
        if record.name == "@":
            query_name = zone_name
        else:
            query_name = f"{record.name}.{zone_name}"

        # Remove trailing dots if present
        query_name = query_name.rstrip(".")

        # Try to resolve the record to detect if it exists
        try:
            answers = resolver.resolve(query_name, record.type)

            # Use pattern matching for different record types
            match record.type:
                case "MX":
                    # MX records have priority and hostname, e.g., "10 mail.example.com."
                    priority, host = record.value.split(" ", 1)
                    priority_int = int(priority)
                    yaml_host = host.rstrip(".")

                    for rdata in answers:
                        rdata_host = str(rdata.exchange).rstrip(".")

                        # For relative hostnames (without trailing dot), append zone name
                        if "." not in yaml_host:
                            expected_fqdn = f"{yaml_host}.{zone_name}".rstrip(".")
                            if (
                                rdata_host == expected_fqdn
                                and rdata.preference == priority_int
                            ):
                                return "match"

                        # Check for exact match (for absolute hostnames)
                        if rdata_host == yaml_host and rdata.preference == priority_int:
                            return "match"

                    return "mismatch"

                case "TXT":
                    # Get the TXT record value from YAML
                    yaml_value = record.value

                    # Remove quotes if they are included in the YAML value
                    if yaml_value.startswith('"') and yaml_value.endswith('"'):
                        yaml_value = yaml_value[1:-1]

                    # Handle multi-part TXT records with spaces between quoted parts
                    yaml_value = yaml_value.replace('" "', "")

                    # Check if any of the returned TXT records match our expected value
                    for rdata in answers:
                        # DNSPython returns TXT records as bytes objects in a list
                        # First join all segments together
                        dns_value = "".join(str(t) for t in rdata.strings)

                        # Remove any 'b' prefixes that might appear in string representation of bytes
                        dns_value = dns_value.replace("b'", "").replace("'", "")

                        # Compare the DNS value with our expected value
                        if dns_value == yaml_value:
                            return "match"

                    return "mismatch"

                case "CNAME":
                    # Get the CNAME target from YAML
                    target = record.value

                    # For a CNAME record, if the target in YAML is relative (doesn't end with a dot),
                    # we need to compare with both the FQDN and the relative name
                    for rdata in answers:
                        dns_target = str(rdata).rstrip(
                            "."
                        )  # Remove trailing dot if present

                        # Check exact match first
                        if dns_target == target:
                            return "match"

                        # Check if the target in the DNS response is the FQDN version of our relative name
                        expected_fqdn = f"{target}.{zone_name}".rstrip(".")
                        if dns_target == expected_fqdn:
                            return "match"

                        # Special case for 'localhost' which might be reported as a FQDN
                        if target == "localhost" and dns_target.startswith(
                            "localhost."
                        ):
                            return "match"

                    return "mismatch"

                case _:
                    # For other record types (A, AAAA, etc.)
                    for rdata in answers:
                        if str(rdata) == record.value:
                            return "match"
                    return "mismatch"

        except dns.resolver.NXDOMAIN:
            # Domain doesn't exist
            return "missing"
        except dns.resolver.NoAnswer:
            # No answer from DNS for this record type
            return "missing"

    except dns.resolver.NoNameservers:
        # No nameservers could be reached
        console.print(
            f"[bold red]Error:[/] checking DNS for {record.name}.{zone_name} ({record.type}): No nameservers could be reached"
        )
        sys.exit(1)
    except Exception as e:
        # Any other error
        console.print(
            f"[bold red]Error:[/] checking DNS for {record.name}.{zone_name} ({record.type}): {e}"
        )
        sys.exit(1)


@click.group(invoke_without_command=True)
@click.option(
    "--dry",
    is_flag=True,
    help="Print the first API request that would be performed and then halt",
)
@click.option(
    "--version",
    is_flag=True,
    help="Show the version and exit",
)
@click.pass_context
def cli(ctx, dry, version):
    """
    Hetzner DNS Manager - A tool to manage DNS records via the Hetzner DNS API using a local database.

    The database consists of one YAML file per zone, stored in directory "./zones".

    The API token has to be provided via the HETZNER_DNS_API_TOKEN environment variable.
    """
    # Show version and exit if requested
    if version:
        click.echo(f"{VERSION} (dns-manager)")
        sys.exit(0)

    # If no subcommand is invoked, show help
    if ctx.invoked_subcommand is None:
        click.echo(ctx.get_help())
        sys.exit(0)

    if not API_TOKEN:
        console.print(
            "[bold red]Error:[/] HETZNER_DNS_API_TOKEN environment variable is not set."
        )
        sys.exit(1)

    # Initialize context object
    ctx.ensure_object(dict)

    # Create API client and store in context
    client = HetznerDNSClient(API_TOKEN, dry_run=dry)
    ctx.obj["client"] = client


@cli.command("import")
@click.argument("domain", required=False)
@click.option("--all", is_flag=True, help="Import all zones")
@click.option(
    "--no-txt-concat", is_flag=True, help="Don't concatenate TXT record values"
)
@click.option(
    "--force",
    is_flag=True,
    help="Force overwrite existing zone files without confirmation",
)
@click.pass_context
def import_zones(ctx, domain, all, no_txt_concat, force):
    """
    Import zones and records from the Hetzner DNS API.

    Specify a domain name to import a single zone, or use --all to import all zones.

    By default, TXT record values with multiple quoted parts (e.g., '"abc" "def"') will be
    concatenated into a single quoted value (e.g., '"abcdef"'). Use --no-txt-concat to
    disable this behavior.

    If a zone file already exists, you'll be prompted for confirmation before overwriting.
    Use --force to skip confirmation and overwrite existing files.
    """
    yaml_handler = YAMLHandler()
    client = ctx.obj["client"]

    try:
        # Get all zones
        zones_data = client.get_all_zones()
        zones = zones_data.get("zones", [])

        if not zones:
            console.print("[yellow]No zones found in your Hetzner DNS account.[/]")
            return

        if all:
            # Import all zones
            for zone_data in zones:
                import_single_zone(
                    zone_data, client, yaml_handler, no_txt_concat, force
                )

        elif domain:
            # Import specific zone
            zone_data = next((z for z in zones if z["name"] == domain), None)

            if not zone_data:
                console.print(
                    f"[bold red]Error:[/] Domain '{domain}' not found in your Hetzner DNS account."
                )
                return

            import_single_zone(zone_data, client, yaml_handler, no_txt_concat, force)

        else:
            console.print("[bold yellow]Please specify a domain or use --all flag.[/]")

    except Exception as e:
        console.print(f"[bold red]Error:[/] {str(e)}")
        sys.exit(1)


@cli.command("check")
@click.argument("domain", required=False)
@click.option("--all", is_flag=True, help="Check all zones")
@click.option(
    "--verbose",
    is_flag=True,
    help="Show detailed output for all zones, including those without errors",
)
@click.pass_context
def check_zones(ctx, domain, all, verbose):
    """
    Check DNS records against actual DNS entries.

    Specify a domain name to check a single zone, or use --all to check all zones.
    """
    yaml_handler = YAMLHandler()
    found_issues = False

    try:
        if all:
            # Check all zones
            for file_path in ZONES_DIR.glob("*.yaml"):
                domain_name = file_path.stem
                zone = yaml_handler.read_zone(domain_name)
                if zone:
                    result = check_zone_records(zone, verbose)
                    if result["missing_records"] or result["mismatch_records"]:
                        found_issues = True

            # Exit with code 1 if any issues were found
            if found_issues:
                sys.exit(1)

        elif domain:
            # Check specific zone
            zone = yaml_handler.read_zone(domain)

            if not zone:
                console.print(
                    f"[bold red]Error:[/] Domain '{domain}' not found in local database."
                )
                sys.exit(1)

            result = check_zone_records(zone, verbose)
            if result["missing_records"] or result["mismatch_records"]:
                sys.exit(1)

        else:
            console.print("[bold yellow]Please specify a domain or use --all flag.[/]")
            sys.exit(1)

    except Exception as e:
        console.print(f"[bold red]Error:[/] {str(e)}")
        sys.exit(1)


def process_txt_record_value(value, concat=True):
    """
    Process TXT record value.
    If concat is True, concatenate multiple quoted parts (e.g., '"abc" "def"' -> '"abcdef"').
    If concat is False, leave as is.
    """
    if not concat or not value.startswith('"') or '"' not in value[1:]:
        return value

    # Extract content from quoted parts and concatenate
    # Match patterns like "abc" "def" "ghi"
    parts = re.findall(r'"([^"]*)"', value)
    if parts:
        return f'"{("").join(parts)}"'

    return value


def import_single_zone(
    zone_data, client, yaml_handler, no_txt_concat=False, force=False
):
    """
    Import a single zone from Hetzner DNS API.

    Args:
        zone_data: Dict containing zone information from API
        client: HetznerDNSClient instance
        yaml_handler: YAMLHandler instance
        no_txt_concat: Flag to disable TXT record concatenation
        force: Skip confirmation and overwrite existing files

    Returns:
        Path to the saved YAML file or None if import was canceled
    """
    zone_id = zone_data["id"]
    zone_name = zone_data["name"]

    console.print(f"Importing zone: [bold]{zone_name}[/]")

    # Check if zone file already exists
    file_path = ZONES_DIR / f"{zone_name}.yaml"
    if file_path.exists() and not force:
        existing_zone = yaml_handler.read_zone(zone_name)
        if existing_zone:
            console.print(f"[yellow]Zone file already exists:[/] {file_path}")
            console.print(
                f"Existing file contains [bold]{len(existing_zone.records)}[/] records."
            )

            if not click.confirm(
                "Do you want to overwrite the existing file?", default=False
            ):
                console.print("[yellow]Import canceled for this zone.[/]")
                return None

    # Get records for this zone
    records_data = client.get_zone_records(zone_id)

    # Create zone object
    zone = Zone(id=zone_id, name=zone_name, records=[])

    # Add records to zone
    for record_data in records_data.get("records", []):
        value = record_data["value"]

        # Process TXT records
        if record_data["type"] == "TXT":
            value = process_txt_record_value(value, not no_txt_concat)

        record = Record(
            id=record_data["id"],
            type=record_data["type"],
            name=record_data["name"],
            value=value,
        )
        zone.records.append(record)

    # Save zone to file
    file_path = yaml_handler.write_zone(zone)
    console.print(
        f"Saved to: [green]{file_path}[/] with [bold]{len(zone.records)}[/] records."
    )

    return file_path


def check_zone_records(zone, verbose=False):
    """
    Check all records in a zone and display results.

    Args:
        zone: Zone object to check
        verbose: If True, show detailed output for all zones, including those without errors
    """
    # Track missing and mismatched records
    missing_records = []
    mismatch_records = []

    # Create table
    table = Table(show_header=True)
    table.add_column("Type", style="cyan")
    table.add_column("Name", style="green")
    table.add_column("Local Value", style="blue")
    table.add_column("Status", style="bold")

    # Check each record
    for record in zone.records:
        # Skip SOA records as they're modified by Hetzner upon update
        if record.type == "SOA":
            continue

        status_code = check_dns_record(record, zone.name)

        # Use pattern matching for status code
        match status_code:
            case "match":
                status = "[green]✓ Match[/]"
            case "mismatch":
                status = "[red]✗ Mismatch[/]"
                mismatch_records.append(record)
            case "missing":
                status = "[red]✗ Missing[/]"
                missing_records.append(record)
            case _:
                status = f"[yellow]? Unknown ({status_code})[/]"

        table.add_row(
            record.type, record.name if record.name else "@", record.value, status
        )

    has_issues = bool(missing_records or mismatch_records)

    # Only print output if there are issues or verbose mode is enabled
    if has_issues or verbose:
        console.print(f"\n[bold]Checking zone:[/] {zone.name}")
        console.print(table)

        if not has_issues:
            console.print("[green]All records match the DNS entries.[/]")
        else:
            if mismatch_records:
                console.print("[yellow]Some records do not match the DNS entries.[/]")
            if missing_records:
                console.print("[yellow]Some records are missing from DNS.[/]")
    elif not verbose and not has_issues:
        # In non-verbose mode with no issues, just print a simple message
        console.print(f"[green]Zone {zone.name}: All records match.[/]")

    return {"missing_records": missing_records, "mismatch_records": mismatch_records}


@cli.command("delete")
@click.argument("domain", required=True)
@click.argument("record_name", required=True)
@click.pass_context
def delete_record_cmd(ctx, domain, record_name):
    """
    Delete a DNS record.

    Requires a domain name and a record name.
    """
    yaml_handler = YAMLHandler()
    client = ctx.obj["client"]

    try:
        # Load zone
        zone = yaml_handler.read_zone(domain)

        if not zone:
            console.print(
                f"[bold red]Error:[/] Domain '{domain}' not found in local database."
            )
            sys.exit(1)

        # Find record by name
        record = next((r for r in zone.records if r.name == record_name), None)

        if not record:
            # Check if the user meant @ for the root domain
            if record_name == "@" or not record_name:
                record = next((r for r in zone.records if r.name == ""), None)

            if not record:
                console.print(
                    f"[bold red]Error:[/] Record '{record_name}' not found in zone '{domain}'."
                )
                sys.exit(1)

        # Confirm deletion
        console.print(
            f"\nDeleting record: [bold]{record.type}[/] [green]{record.name}[/] [blue]{record.value}[/]"
        )

        # Delete from API
        client.delete_record(record.id)
        console.print("[green]Record deleted from Hetzner DNS.[/]")

        # Ask user to update YAML file
        if click.confirm(
            "Do you want to update the YAML file to remove this record?", default=True
        ):
            # Remove the record from the zone
            zone.records = [r for r in zone.records if r.id != record.id]

            # Save the updated zone
            file_path = yaml_handler.write_zone(zone)
            console.print(f"[green]Updated YAML file:[/] {file_path}")
        else:
            # Display the current message if user declines
            console.print(
                f"\n[yellow]Please update the YAML file to remove this record:[/] {ZONES_DIR / f'{domain}.yaml'}"
            )

    except Exception as e:
        console.print(f"[bold red]Error:[/] {str(e)}")
        sys.exit(1)


@cli.command("update")
@click.argument("domain", required=False)
@click.option("--all", is_flag=True, help="Update all zones")
@click.pass_context
def update_zones(ctx, domain, all):
    """
    Check and update DNS records.

    Specify a domain name to update a single zone, or use --all to update all zones.
    """
    yaml_handler = YAMLHandler()
    client = ctx.obj["client"]

    try:
        if all:
            # Update all zones
            for file_path in ZONES_DIR.glob("*.yaml"):
                domain_name = file_path.stem
                zone = yaml_handler.read_zone(domain_name)
                if zone:
                    process_zone_update(zone, yaml_handler, client)

        elif domain:
            # Update specific zone
            zone = yaml_handler.read_zone(domain)

            if not zone:
                console.print(
                    f"[bold red]Error:[/] Domain '{domain}' not found in local database."
                )
                sys.exit(1)

            process_zone_update(zone, yaml_handler, client)

        else:
            console.print("[bold yellow]Please specify a domain or use --all flag.[/]")
            sys.exit(1)

    except Exception as e:
        console.print(f"[bold red]Error:[/] {str(e)}")
        sys.exit(1)


def process_zone_update(zone, yaml_handler, client):
    """Process the update for a zone."""
    console.print(f"\n[bold]Checking zone:[/] {zone.name}")

    # Check records and get detailed results
    check_result = check_zone_records(zone, verbose=False)

    # Get missing and mismatched records from the check result
    missing_records = check_result["missing_records"]
    mismatch_records = check_result["mismatch_records"]

    # If no missing or mismatched records, nothing to do
    if not missing_records and not mismatch_records:
        console.print("[green]All records match. No update needed.[/]")
        return True

    # Handle missing records first
    if missing_records:
        console.print(f"\nFound [bold]{len(missing_records)}[/] missing records:")
        for record in missing_records:
            display_name = record.name if record.name else "@"
            console.print(f"  - {record.type} {display_name} {record.value}")

        # Ask for confirmation to create missing records
        if click.confirm("Do you want to create the missing records?", default=True):
            # Prepare records for bulk create
            create_records = []
            for record in missing_records:
                create_records.append(
                    {
                        "zone_id": zone.id,
                        "type": record.type,
                        "name": record.name,
                        "value": record.value,
                    }
                )

            # Perform bulk create
            console.print(f"Creating [bold]{len(create_records)}[/] records...")

            result = client.bulk_create_records(create_records)

            # Handle invalid records
            if "invalid_records" in result and result["invalid_records"]:
                console.print("[bold red]Error:[/] Some records failed to create:")
                for record in result["invalid_records"]:
                    display_name = record["name"] if record["name"] else "@"
                    console.print(
                        f"  - {record['type']} {display_name} {record['value']}"
                    )

            # Handle successfully created records
            if "records" in result and result["records"]:
                console.print(
                    f"[green]Successfully created {len(result['records'])} records.[/]"
                )

                # Ask user to update YAML files to include newly created records
                if click.confirm(
                    "Do you want to update the YAML file with the new record IDs?",
                    default=True,
                ):
                    # Update record IDs in zone object
                    for new_record in result["records"]:
                        for record in zone.records:
                            if (
                                record.type == new_record["type"]
                                and record.name == new_record["name"]
                                and record.value == new_record["value"]
                            ):
                                record.id = new_record["id"]

                    # Save the updated zone
                    file_path = yaml_handler.write_zone(zone)
                    console.print(f"[green]Updated YAML file:[/] {file_path}")

    # Handle mismatched records
    if mismatch_records:
        console.print(f"\nFound [bold]{len(mismatch_records)}[/] mismatched records:")
        for record in mismatch_records:
            display_name = record.name if record.name else "@"
            console.print(f"  - {record.type} {display_name} {record.value}")

        # Ask for confirmation to update mismatched records
        if click.confirm("Do you want to update the mismatched records?", default=True):
            # Prepare records for bulk update
            update_records = []
            for record in mismatch_records:
                update_records.append(
                    {
                        "id": record.id,
                        "type": record.type,
                        "name": record.name,
                        "value": record.value,
                        "zone_id": zone.id,
                    }
                )

            # Perform bulk update
            console.print(f"Updating [bold]{len(update_records)}[/] records...")

            result = client.bulk_update_records(update_records)

            if "failed_records" in result and result["failed_records"]:
                console.print("[bold red]Error:[/] Some records failed to update:")
                for record in result["failed_records"]:
                    display_name = record["name"] if record["name"] else "@"
                    console.print(
                        f"  - {record['type']} {display_name} {record['value']}"
                    )
            else:
                console.print("[green]All records updated successfully.[/]")

    return True


if __name__ == "__main__":
    cli()
